import ImageRenderer from "../../../components/ui/ImageRenderer"
import Assignment from "../../../components/ui/Assignment"

# Contents

<div className="content">
- [What is Go?](#what-is-go)
- [Why do we use Go ?](#why-do-we-use-go-)
- [Usecases of Go](#usecases-of-go)
- [Assignment 1](#assignment-1)
- [Assignment 2](#assignment-2)
- [Wallrus Operator](#wallrus-operator)
- [Why is there no need of semicolon in Go ?](#why-is-there-no-need-of-semicolon-in-go-)
  - [What keywords are we talking about ?](#what-keywords-are-we-talking-about-)
  - [What are line breaks ?](#what-are-line-breaks-)
  - [What are the exceptions ?](#what-are-the-exceptions-)
- [Go is fast, simple and productive](#go-is-fast-simple-and-productive)
- [Compilation Process](#compilation-process)
- [Structure of a Go program](#structure-of-a-go-program)
- [Much detailed Compilation](#much-detailed-compilation)
- [Compiled VS Interpreted](#compiled-vs-interpreted)
  - [Compiled languages](#compiled-languages)
  - [Interpreted languages](#interpreted-languages)
- [Why to use compiled languages ?](#why-to-use-compiled-languages-)
- [Go is strongly typed](#go-is-strongly-typed)
  - [Example of strong typing](#example-of-strong-typing)
- [Go programs are easy on memory](#go-programs-are-easy-on-memory)
  - [What is Go Runtime ?](#what-is-go-runtime-)
  - [Comparison](#comparison)
  
</div>

# What is Go? 

Go is an open source programming language that makes it easy to build simple, reliable, and efficient software. Go is a statically typed, compiled language in the tradition of C, with memory safety, garbage collection, structural typing, and CSP-style concurrency. The compiler, tools, and source code are all free and open source.

# Why do we use Go ?

- Go is a compiled language, which means that it is fast.
- Go is a statically typed language, which means that it is safe.
- Go has a simple syntax, which means that it is easy to learn.
- Go has a small standard library, which means that it is easy to understand.


# Usecases of Go

- Docker uses Go for its core container runtime and networking components by using the libcontainer project, which provides a native Go implementation of the container/exec driver for Linux operating systems.
- Kubernetes uses Go for its cluster management and container orchestration capabilities.
- Terraform uses Go to provide a simple, safe and elegant way to manage your cloud infrastructure.
- Hugo uses Go to provide a static site generator.
- CockroachDB uses Go to provide a distributed SQL database.
- InfluxDB uses Go to provide a time series database.


# Assignment 1

<Assignment isQuestion={true} details={"Assignment: log `starting Textio server` to the console instead of hello world."}/>

```go
package main

import "fmt"

func main() {
	// single-line comments start with "//"
	// comments are just for documentation - they don't execute
	fmt.Println("starting Textio server")
}
```

Here `fmt` is a package that contains functions for formatting text. `Println` is a function that prints a line of text to the console.
`package main` tells the Go compiler that this is a program that can be run, as opposed to a library that can be imported into other programs.

# Assignment 2

<Assignment isQuestion={true} details={"Textio users are reporting that we're billing them for wildly inaccurate amounts. They're supposed to be billed `.02` dollars for each text message sent."}/>

**Given Code**

```go
package main

import "fmt"

func main() {
	messagesFromDoris := []string{
		"You doing anything later??",
		"Did you get my last message?",
		"Don't leave me hanging...",
		"Please respond I'm lonely!",
	}
	numMessages := float64(len(messagesFromDoris))
	costPerMessage := .02

	// don't touch above this line

	totalCost := costPerMessage + numMessages

	// don't touch below this line

	fmt.Printf("Doris spent %.2f on text messages today\n", totalCost)
}
```
<Assignment isQuestion={false} details={"The solution would be to replace the `+` with `*` in the line `totalCost := costPerMessage + numMessages` and you're done."}/>


Just replace the `+` with `*` in the line `totalCost := costPerMessage + numMessages` and you're done.

# Wallrus Operator

The walrus operator `:=` is a short variable declaration operator. It is used to declare and initialize a variable at the same time. It is shorthand for declaring a variable and then assigning a value to it.

```go
package main

import "fmt"

func main() {
	// single-line comments start with "//"
	// comments are just for documentation - they don't execute
	// fmt.Println("starting Textio server")

	// walrus operator
	// var name string = "Doris"
	// var name = "Doris"
	name := "Doris"

	fmt.Println("Hello", name)
}
```
Now if we check the type of the variable `name` we get `string` as the output.

```go
fmt.Printf("%T", name)
// string
```


# Why is there no need of semicolon in Go ?

Go is a semicolon-free language. The Go compiler automatically inserts semicolons at the end of each line. This is called semicolon insertion. The Go compiler is smart enough to know when to insert semicolons. It does this by looking for line breaks and keywords that signal the end of a statement.

## What keywords are we talking about ?

- `break`
- `continue`
- `fallthrough`
- `return`

## What are line breaks ?

- `}` closing curly brace
- `)` closing parenthesis
- `]` closing square bracket

## What are the exceptions ?

- `++` increment operator
- `--` decrement operator

# Go is fast, simple and productive

Generally speaking, compiled languages run much faster than interpreted languages, and Go is no exception.

Go is one of the fastest programming languages, beating JavaScript, Python, and Ruby handily in most benchmarks.

However, Go code doesn't run quite as fast as its compiled Rust and C counterparts. That said, it compiles much faster than they do, which makes the developer experience super productive. Unfortunately, there are no swordfights on Go teams...

Go code generally runs `faster` than interpreted languages and compiles `faster` than other compiled languages like C and Rust

Go is a bit slower mostly due to its automated memory management, also known as the "Go runtime". Slightly slower speed is the price we pay for memory safety and simple syntax!

<ImageRenderer img="https://miro.medium.com/v2/resize:fit:2020/1*nlpYI256BR71xMBWd1nlfg.png"/>

# Compilation Process

Computers need machine code, they don't understand English or even Go. We need to convert our high-level (Go) code into machine language, which is really just a set of instructions that some specific hardware can understand. In your case, your CPU.

The Go compiler's job is to take Go code and produce machine code. On Windows, that would be a .exe file. On Mac or Linux, it would be any executable file. 

For example you made a file called `main.go` and you want to compile it. You can do that by running the following command in your terminal.

```bash
go build main.go
```

This will create an executable file called `main` in your current directory. You can run it by typing `./main` in your terminal.



# Structure of a Go program

We'll go over this all later in more detail, but to sate your curiosity for now, here are a few tidbits about the code.

- `package main` lets the Go compiler know that we want this code to compile and run as a standalone program, as opposed to being a library that's imported by other programs.
- `import fmt` imports the fmt (formatting) package. The formatting package exists in Go's standard library and lets us do things like print text to the console.
- `func main()` defines the main function. main is the name of the function that acts as the entry point for a Go program.

# Much detailed Compilation

Computers don't know how to do anything unless we as programmers tell them what to do. Unfortunately computers don't understand human language. In fact, they don't even understand uncompiled computer programs.

For example, the code means nothing to a computer. It's just a bunch of text. We need to convert our high-level (Go) code into machine language, which is really just a set of instructions that some specific hardware can understand. In your case, your CPU.

```go
package main

import "fmt"

func main(){
  fmt.Println("hello world")
}
```
A computer's CPU only understands its own instruction set, which we call "machine code". Instructions are basic math operations like addition, subtraction, multiplication, and the ability to save data temporarily.

For example, an ARM processor uses the ADD instruction when supplied with the number `0100` in binary.

**Go, C, and Rust** are all languages where the code is first converted to machine code by the compiler before it's executed. This is called compilation. The Go compiler's job is to take Go code and produce machine code. On Windows, that would be a .exe file. On Mac or Linux, it would be any executable file.

# Compiled VS Interpreted

Compiled programs can be run without access to the original source code, and without access to a compiler. For example, when your browser executes the code you write in this course, it doesn't use the original code, just the compiled result.

Note how this is different than interpreted languages like Python and JavaScript. With Python and JavaScript the code is interpreted at runtime by a separate program known as the "interpreter". Distributing code for users to run can be a pain because they need to have an interpreter installed, and they need access to the original source code.

<ImageRenderer img="https://i.imgur.com/uqnMubj.png" />

## Compiled languages

- C
- C++
- Go
- Rust

## Interpreted languages

- JavaScript
- Python
- Ruby

<ImageRenderer img="https://i.imgur.com/ovHaWmS.jpg" />

# Why to use compiled languages ?

One of the most convenient things about using a compiled language like Go for Textio is that when we deploy our server we don't need to include any runtime language dependencies like Node or a Python interpreter. We just add the pre-compiled binary to the server and start it up!

<Assignment isQuestion={true} details={"Do users of compiled programs need access to source code?"} />

<Assignment isQuestion={false} details={"No, users of compiled programs don't need access to the source code. They just need the compiled binary. Because compiled programs are already converted to machine code, they can be run without access to the original source code, and without access to a compiler."} />

<br/>

<Assignment isQuestion={true} details={"Why is it generally more simple to deploy a compiled server program?"} />

<Assignment isQuestion={false} details={"Because there are no runtime dependencies like Node or a Python interpreter. We just add the pre-compiled binary to the server and start it up!"} />





# Go is strongly typed

Go enforces strong and static typing, meaning variables can only have a single type. A `string` variable like "hello world" can not be changed to an `int`, such as the number `3`.

One of the biggest benefits of strong typing is that errors can be caught at "compile time". In other words, bugs are more easily caught ahead of time because they are detected when the code is compiled before it even runs.

Contrast this with most interpreted languages, where the variable types are dynamic. Dynamic typing can lead to subtle bugs that are hard to detect. With interpreted languages, the code must be run to catch syntax and type errors. (sometimes in production if you are unlucky 😨)

## Example of strong typing

```go
package main
import "fmt"

func main() {
  var name string = "Doris"
  name = 3 // this will throw an error
  fmt.Println(name)

  var a = "Hello"
  var b = 77
  fmt.Println(a + b) // this will throw an error
}
```


# Go programs are easy on memory

Go programs are fairly lightweight. Each program includes a small amount of "extra" code that's included in the executable binary. This extra code is called the Go Runtime. One of the purposes of the Go runtime is to cleanup unused memory at runtime.

In other words, the Go compiler includes a small amount of extra logic in every Go program to make it easier for developers to write code that's memory efficient.

## What is Go Runtime ?

Go does have an extensive library, called the runtime, that is part of every Go program. The runtime library implements garbage collection, concurrency, stack management, and other critical features of the Go language. Although it is more central to the language, Go's runtime is analogous to libc, the C library.

It is important to understand, however, that Go's runtime does not include a virtual machine, such as is provided by the Java runtime. Go programs are compiled ahead of time to native machine code (or JavaScript or WebAssembly, for some variant implementations). Thus, although the term is often used to describe the virtual environment in which a program runs, in Go the word “runtime” is just the name given to the library providing critical language services.

## Comparison

As a general rule Java programs use more memory than comparable Go programs because Go doesn't use an entire virtual machine to run its programs, just a small runtime. The Go runtime is small enough that it is included directly in each Go program's compiled machine code.

As another general rule Rust and C++ programs use slightly less memory than Go programs because more control is given to the developer to optimize memory usage of the program. The Go runtime just handles it for us automatically.

<ImageRenderer img="https://miro.medium.com/max/1400/1*Ggs-bJxobwZmrbfuoWGpFw.png" />

In the chart above, Dexter Darwich compares the memory usage of three very simple programs written in Java, Go, and Rust. As you can see, Go and Rust use very little memory when compared to Java.


export default ({children}) => <div className="prose md">{children}</div>